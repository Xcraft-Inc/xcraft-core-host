#!/usr/bin/env node
'use strict';

const moduleName = 'xcraft-core-host';

const {app} = require ('electron');
const watt = require ('watt');
const path = require ('path');
const xLog = require ('xcraft-core-log') (moduleName);

class Host {
  constructor () {
    if (!process.env.XCRAFT_LOG && process.env.NODE_ENV === 'production') {
      process.env.XCRAFT_LOG = '2';
    }

    this._isElectron = !!process.versions.electron;
    this._appConfigPath = {};

    const config = require ('../lib/index.js');

    if (config.appEnv === 'release' && !process.env.NODE_ENV) {
      process.env.NODE_ENV = 'production';
    }

    this._appConfigPath = config.appConfigPath;

    this._xServer = require ('xcraft-server') (
      config.appConfigPath,
      config.projectPath
    );

    if (this._isElectron) {
      xLog.info (`electron runtime detected,`);
      app.on ('window-all-closed', () => {}); /* Prevent the app exiting */
    } else {
      xLog.info (`node runtime detected`);
    }

    xLog.info (`config; ${JSON.stringify (config, null, 2)}`);

    const etcRoot = path.join (this._appConfigPath, 'etc');
    this._xConfig = require ('xcraft-core-etc') (etcRoot).load (moduleName);

    watt.wrapAll (this);
  }

  *_startAndRunMainQuest (busClient, next) {
    yield this._xServer.start (next);

    /* HACK: force and unusual orc name.
     * The problem is that the greathall::* topic is already registered, then
     * when this BusClient is used to send commands, an other orc name must
     * be used in order to handle properly all subscribes of events.
     */
    busClient._orcName = 'host';

    yield busClient.connect (
      'ee',
      require ('xcraft-core-busclient').getGlobal ().getToken (),
      next
    );

    /* Start the main quest (app bootstrap). */
    yield busClient.command.send (this._xConfig.mainQuest, null, null, next);
  }

  *boot (next) {
    if (this._isElectron) {
      app.once ('ready', next.parallel ().arg (0));
    }

    const {BusClient} = require ('xcraft-core-busclient');
    const busClient = new BusClient ();

    this._startAndRunMainQuest (busClient, next.parallel ());
    yield next.sync ();

    /* Start the secondary quest (electron ready) */
    yield busClient.command.send (
      this._xConfig.secondaryQuest,
      null,
      null,
      next
    );
  }
}

const host = new Host ();
host.boot ().catch (xLog.err);
