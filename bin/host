#!/usr/bin/env node
'use strict';

/* HACK: workaround when require.resolve is used on modules
 * that are created as junctions on Windows. When a junction
 * is resolved to the real directory, the drive letter doesn't
 * use the same case. It's a major problem when a module is
 * required from module in node_modules/ and other modules
 * in lib/ (referenced in node_modules/ with a junction).
 */
const Module = require('module');
const origResolveFilename = Module._resolveFilename;
Module._resolveFilename = function () {
  const result = origResolveFilename.apply(this, arguments);
  return result.replace(/^([a-z]):/, (c) => c.toUpperCase());
};

let electron;
try {
  electron = require('electron');
} catch (ex) {
  if (ex.code !== 'MODULE_NOT_FOUND') {
    throw ex;
  }
}
const isElectron =
  !!process.versions.electron && electron && typeof electron !== 'string';

const moduleName = 'xcraft-core-host';
const watt = require('gigawatts');
const xLog = require('xcraft-core-log')(moduleName);

class Host {
  constructor(isElectron) {
    /* Prepare GOBLINS_APP environment variable */
    const appArg = process.argv.reduce((res, arg, it, arr) => {
      if (/^--app=/.test(arg)) {
        //                           --app=venture-trade-company
        res.unshift(arg.split('=')[1]);
      } else if (
        /^-[b-z]+a$/.test(arg) || //   -da venture-trade-company
        arg === '-a' || //              -a venture-trade-company
        arg === '--app' //           --app venture-trade-company
      ) {
        res.unshift(arr[it + 1]);
      }
      return res;
    }, []);
    if (appArg.length > 0) {
      process.env.GOBLINS_APP = appArg[0];
      if (!process.env.GOBLINS_APP_MASTER) {
        process.env.GOBLINS_APP_MASTER = process.env.GOBLINS_APP;
      }
    }

    const config = require('../lib/index.js');

    if (!process.env.GOBLINS_APP) {
      process.env.GOBLINS_APP = config.appId;
    }
    if (!process.env.GOBLINS_APP_MASTER) {
      process.env.GOBLINS_APP_MASTER = config.appMasterId;
    }

    if (config.appEnv === 'release' && !process.env.NODE_ENV) {
      process.env.NODE_ENV = 'production';
    }

    if (!process.env.XCRAFT_LOG && process.env.NODE_ENV !== 'development') {
      process.env.XCRAFT_LOG = '2';
    }
    this._isElectron = isElectron;
    this._app = null;
    this._appConfigPath = config.appConfigPath;
    this._ignoreCloseRequests = false;
    this._powerSaveBlockerIds = [];

    this._xServer = require('xcraft-server')(
      config.appConfigPath,
      config.projectPath,
      () => require('../lib/args-parsing.js')()
    );

    this._xConfig = require('xcraft-core-etc')().load(moduleName);

    xLog.dbg(`process arguments: ${process.argv.join(' ')}`);

    process.on('uncaughtException', (ex) => {
      xLog.err(
        `Please, ensure to yield properly all async calls: ${
          ex.stack || ex.message || ex
        }`
      );
    });

    if (this._isElectron) {
      xLog.info(`electron runtime detected,`);
      const {app, powerSaveBlocker} = require('electron');
      this._app = app;

      if (this._xConfig.singleInstance) {
        const gotTheLock = this._app.requestSingleInstanceLock();
        if (!gotTheLock) {
          this._app.quit();
        } else {
          this._app.on(
            'second-instance',
            (event, commandLine, workingDirectory) => {
              try {
                commandLine = require('../lib/args-parsing.js')(
                  true,
                  commandLine
                );
                if (this._busClient && this._busClient.isConnected()) {
                  this._notifyNewInstance(commandLine, workingDirectory);
                }
              } catch (err) {
                xLog.err(err.stack || err.message || err);
              }
            }
          );
        }
      }

      this._app.on('window-all-closed', () => {
        if (this._ignoreCloseRequests) {
          const MsgBox = require('../lib/msgbox.js');
          const alert = new MsgBox();
          alert.open('waiting for application restart...');
          return;
        }
        if (this._busClient && this._busClient.isConnected()) {
          this._notifyAppClosed();
        } else {
          this._app.quit();
        }
      });

      // Specific for macOS
      this._app.on('open-file', (ev, filePath) => {
        if (this._busClient && this._busClient.isConnected()) {
          this._notifyOpenFile(filePath);
        } else {
          this.filePath = filePath;
        }
        ev.preventDefault();
      });

      for (const blockerType of this._xConfig.powerSaveBlockers) {
        this._powerSaveBlockerIds.push(powerSaveBlocker.start(blockerType));
      }
    } else {
      xLog.info(`node runtime detected`);
    }

    xLog.info(`config; ${JSON.stringify(config, null, 2)}`);

    watt.wrapAll(this);
  }

  // FIXME: not 100% accurate..
  _terminate() {
    if (this._unsubLineUpdated) {
      this._unsubLineUpdated();
    }
    if (this._busClient) {
      this._busClient.command.send('shutdown');
    }

    if (this._isElectron) {
      const {powerSaveBlocker} = require('electron');
      for (const powerSaveId of this._powerSaveBlockerIds) {
        powerSaveBlocker.stop(powerSaveId);
      }
    }
  }

  _notifyOpenFile(filePath) {
    if (!this._xConfig.openFileQuest) {
      return;
    }
    this._busClient.command.send(
      this._xConfig.openFileQuest,
      {filePaths: [filePath]},
      null,
      (err) => {
        if (err) {
          xLog.err(err.stack || err.message || err);
        }
      }
    );
  }

  _notifyAppClosed() {
    this._terminate();
  }

  _notifyNewInstance(commandLine, workingDirectory) {
    if (!this._xConfig.newInstanceQuest) {
      return;
    }
    this._busClient.command.send(
      this._xConfig.newInstanceQuest,
      {commandLine, workingDirectory},
      null,
      (err) => {
        if (err) {
          xLog.err(err.stack || err.message || err);
        }
      }
    );
  }

  *_init(xBus, next) {
    /* HACK: force and unusual orc name.
     * The problem is that the greathall::* topic is already registered, then
     * when this BusClient is used to send commands, an other orc name must
     * be used in order to handle properly all subscribes of events.
     */
    let connected = false;

    const _next = next.parallel();
    const unsub = this._busClient.events.subscribe(`greathall::loaded`, () => {
      unsub();
      _next();
    });

    this._ignoreCloseRequests = false;
    const onReconnect = (callback) => {
      this._busClient
        .on('reconnect', () => callback('done'))
        .on('reconnect attempt', () => callback('attempt'));
      return () => {
        this._busClient.removeListener('reconnect', callback);
        this._busClient.removeListener('reconnect attempt', callback);
      };
    };

    onReconnect((status) => {
      switch (status) {
        case 'attempt':
          this._ignoreCloseRequests = true;
          xLog.warn('Connection lost with the server, attempt a reconnection');
          break;
        case 'done':
          this._ignoreCloseRequests = false;
          xLog.dbg('New connection done');
          break;
      }
    });

    const onCommandsRegistry = () => {
      if (!this._busClient.isConnected() || !connected) {
        return;
      }
      this._busClient.removeListener('commands.registry', onCommandsRegistry);
      this._busClient.command.send('goblin._init', null, null, () => {}, {
        forceNested: true,
      });
    };
    this._busClient.on('commands.registry', onCommandsRegistry);

    const isLoaded = yield this._busClient.connect('ee', null, next);
    if (isLoaded) {
      unsub();
      _next();
    }

    connected = true;
    yield next.sync();

    this._unsubLineUpdated = this._busClient.events.subscribe(
      '*::warehouse.lines-updated',
      (msg) => {
        const {Router} = require('xcraft-core-transport');
        Router.updateLines(msg.data.lines, msg.data.token, msg.data.generation);
      }
    );

    xBus.notifyCmdsRegistry();
  }

  *_startAndRunMainQuest(next) {
    /* Start the main quest (app bootstrap). */
    yield this._busClient.command.send(
      this._xConfig.mainQuest,
      null,
      null,
      next
    );
  }

  *_bootstrapHorde() {
    const xHorde = require('xcraft-core-horde');
    if (xHorde.config.autoload) {
      const resp = this._busClient.newResponse(moduleName);
      yield xHorde.autoload(resp);
    }
  }

  *boot(next) {
    if (this._xConfig.prologModuleLoad) {
      /* Ensure that the event loop is empty (handle macOS open-file events), then continue */
      yield setTimeout(next, 100);
      require(this._xConfig.prologModuleLoad)(this);
    }

    yield this._xServer.start(next);

    const {BusClient} = require('xcraft-core-busclient');
    const xBus = require('xcraft-core-bus');

    this._busClient = new BusClient();
    this._busClient._orcName = xBus.generateOrcName();

    if (this._isElectron && !this._xConfig.disableGoblinWM) {
      const WM = require('../lib/wm.js');
      WM.instance.initBus();
    }

    if (xBus._commander.isModuleRegistered('horde')) {
      yield this._bootstrapHorde();
    }

    yield this._init(xBus);

    if (this._xConfig.mainQuest) {
      let alert;

      this._startAndRunMainQuest(next.parallel());
      if (this._app) {
        const _next = next.parallel();
        this._app
          .whenReady()
          .then(() => _next())
          .catch(_next);

        const appArgs = require('../lib/args-parsing.js')();

        if (this._isElectron && appArgs['relaunch-reason']) {
          const {app} = require('electron');
          let message = `${app.getName()} is restarting, please wait...`;
          if (appArgs) {
            switch (appArgs['relaunch-reason']) {
              case 'client-connection':
                message = `${app.getName()} is restarting after a connection lose, please wait...`;
                break;
              case 'server-restart':
                message = `${app.getName()} is restarting after a server restart, please wait...`;
                break;
            }
          }

          const MsgBox = require('../lib/msgbox.js');
          alert = new MsgBox();
          alert.open(message);
        }
      }
      yield next.sync();

      if (this._xConfig.afterLoadQuests) {
        for (const quest of this._xConfig.afterLoadQuests) {
          yield this._busClient.command.send(quest, null, null, next, {
            forceNested: true,
          });
        }
      }

      xBus.acceptIncoming();

      if (this.filePath) {
        this._notifyOpenFile(this.filePath);
        this.filePath = null;
      }

      if (alert) {
        setTimeout(() => alert.close(), 4000);
      }

      if (this._xConfig.secondaryQuest) {
        /* Start the secondary quest (electron ready) */
        yield this._busClient.command.send(
          this._xConfig.secondaryQuest,
          null,
          null,
          next
        );
      }
    } else {
      xBus.acceptIncoming();
    }
  }
}

const host = new Host(isElectron);
host.boot().catch((err) => {
  xLog.err(err);
});
